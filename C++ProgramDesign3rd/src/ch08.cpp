#include <iostream>
#include "ch08.h"

using namespace std;

void ch08()
{
	//P252，Ch08，多态性
	//8.1 多态性概述
	//	多态是指同样的消息被不同类型的对象接收时导致不同的行为。
	//	消息是指对类的成员函数的调用。
	//	行为是指实现。
	//	8.1.1 多态的类型：专用多态（重载多态、强制多态）、通用多态（包含多态、参数多态）。
	//		普通函数及类的成员函数的重载，称为重载多态。
	//		将一个变元的类型加以变化，以符合一个函数或者操作的要求，称为强制多态。
	//		研究类族中定义于不同类中的同名成员函数的多态行为，称为包含多态，主要通过虚函数实现。
	//		参数多态与类模板（Ch09）相关联，在使用时必须赋予实际的类型才可以实例化。
	//	8.1.2 多态的实现：
	//		编译时的多态：编译的过程中确定同名操作的具体操作对象，
	//		运行时的多态：程序运行过程中才动态地确定同名操作的具体操作对象，
	//		确定操作的具体对象的过程，称为绑定（binding，也叫联编）。
	//		绑定是指计算机程序自身彼此关联的过程，也就是把一个标识符名和一个存储地址联系在一起的过程，也是把一条消息和一个对象的方法相结合的过程。
	//		静态绑定：绑定工作在编译阶段完成的情况
	//		动态绑定：绑定工作在程序运行阶段完成的情况
	//8.2 运算符重载：对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为
	//	8.2.1 运算符重载的规则
	//		1）C++中的运算符可以重载（除了少数几个），但是只能重载C++中已有的运算符
	//		2）重载之后运算符的优先级和结合性没有改变
	//		3）运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造
	//		不能重载的运算符：类属关系运算符“.”、成员指针运算符“ * ”、作用域分辨符“::”、sizeof运算符、三目运算符“ ? : ”。
	//		函数类型指定了重载运算符的返回值类型，即运算结果类型；
	//		operator 是定义运算符重载函数的关键字；
	//		运算符是要重载的运算符名称，必须是C++中可重载的运算符；
	//		形参表中给出重载运算符所需要的参数和类型；
	//		运算符重载为友元函数时需要使用 friend 关键字来声明。
	//	8.2.2 运算符重载为成员函数
	//	8.2.3 运算符重载为友元函数
	//8.3 虚函数：动态绑定的基础，必须是非静态的成员函数，经过派生之后，在类族中就可以实现运行过程中的多态。
	//	8.3.1 一般虚函数成员
	//		虚函数的声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。
	//		运行过程中使用多态的三个条件：1）类之间满足类型兼容规则；2）声明虚函数；3）由成员函数来调用或者是通过指针、引用来访问虚函数。
	//		派生类的虚函数会覆盖基类的虚函数。
	//		派生类的虚函数还会隐藏基类中同名函数中的所有重载形式。
	//	8.3.2 虚析构函数：在C++中，不能声明虚构造函数，可以声明虚析构函数。
	//8.4 抽象类：带有纯虚函数的类
	//	8.4.1 纯虚函数：不会给出函数的实现部分
	//	8.4.2 抽象类：带有纯虚函数的类是抽象类，抽象类不能实例化


	cout << "===>Ch08<===" << endl;

	src0801(); cout << endl;
	src0802(); cout << endl;
	src0803(); cout << endl;
}
