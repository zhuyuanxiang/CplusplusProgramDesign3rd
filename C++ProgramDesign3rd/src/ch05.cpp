#include <iostream>
#include "ch05.h"

using namespace std;

void ch05()
{
	//	P125，Ch05，C++程序的结构
	//5.1 标识符的作用域与可见性
	//	5.1.1 作用域：标识符在程序正文中有效的区域（函数原型作用域、块作用域即局部作用域、类作用域、文件作用域）
	//	1. 函数原型作用域：在函数原型声明时形式参数的作用范围
	//	2. 块作用域：在块中声明的标识符，其作用域从声明处开始，到块结束为止。具有块作用域的变量也称为局部变量
	//	3. 类作用域：在类的成员函数中如果没有声明同名的局部作用域标识符，那么在该函数内可以直接访问类的成员。变量x通过x::M或x.M访问，指针ptr通过ptr->M访问
	//	4. 文件作用域：在文件中声明的不同于其他三个的标识符，其作用域从声明处开始，到文件结束为止。
	//5.2 对象的生存期
	//	5.2.1 静态生存期：对象的生存期与程序的运行期相同
	//	5.2.2 动态生存期：对象自重于声明点，结束于该标识符作用域结束处。
	//5.3 类的静态成员变量：方便同一个类的不同对象之间共享数据。
	//	5.3.1 静态数据成员：
	//	实例属性：在类的每一个对象中都拥有一个实例，是每个对象之间的区别特征
	//	类属性：整个类所共有，不属于任何一个具体的对象。描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的。
	//	静态数据成员具有静态生存期，使用“类名::标识符”进行访问
	//	5.3.2 静态函数成员：可以直接访问该类的静态数据和函数成员。而访问非静态数据成员必须通过参数传递方式得到对象名，然后通过对象名来访问。
	//5.4 类的友元：
	//	友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。
	//	通过友元关系，一个普通函数或者类的成员函数可以访问封装于另一个类中的数据。
	//	同时，友元关系也是对数据隐藏和封装的破坏。
	//	5.4.1 友元函数：在类中使用关键字friend修饰的非成员函数
	//	友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是在补给线的函数体中可以通过对象名访问类的私有和保护成员。
	//	5.4.2 友元类：若A类是B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有成员和保护成员。
	//	友元关系不可传递；友元关系是单向的；友元关系不能继承。
	//5.5 共享数据的保护
	//	5.5.1 常引用：所引用的对象不能被更新
	//	5.5.2 常对象：必须进行初始化，而且不能被更新
	//	5.5.3 使用 const 修饰的对象的常成员
	//		1. 常成员函数：[类型说明符 函数名(参数表) const;]
	//			-	const 是函数类型的一个组成部分，因此在函数的定义部分也要带 const 关键字
	//			-	常成员函数不能更新对象的数据成员，也不能调用该类中没有用 const 修饰的成员函数（保证了在常成员函数中不会更改数据成员的值）
	//			-	通过常对象只能调用常成员函数，不能调用其他成员函数
	//			-	const 关键字可以用于对重载函数的区分
	//		2. 常数据成员
	//5.6 多文件结构和编译预处理命令
	//	5.6.1 C++程序的一般组织结构：类定义文件(h)、类实现文件(cpp)、类使用文件(cpp)
	//	图5 - 8：C++多文件组织结构图
	//	#include的两种书写方式：
	//		#include<文件名>：表示按照标准方式搜索要嵌入的文件，该文件位于C++系统目录的include子目录下，一般要嵌入系统提供的标准文件时采用这种方式
	//		#include"文件名"：表示首先在当前目录搜索要嵌入的文件，如果没有再按照标准方式搜索，一般对用户编写的文件采用这种方式
	//	5.6.2 外部变量与外部函数
	//		1. 外部变量：使变量既可以在源文件使用，还可以被其他文件使用，可以将其声明为外部变量，用extern关键字来说明
	//			外部变量可以用extern在多处声明，但是对变量的定义和初始化只能是惟一的。
	//			定义一个文件作用域的变量时，其默认状态是可以为不同的编译单元共享，只要在其他编译单元使用extern声明变量即可。
	//			如果使用static声明变量时，则该变量的作用域则仅限于定义它的编译单元，在其他编译单元中不能访问。
	//		2. 外部函数：在所有类之外声明的函数都是具有文件作用域的，即这些函数可以在不同的编译单元中调用，只要在调用之前声明函数原型即可。
	//			如果使用static修饰定义的函数时，函数的作用域则限制在当前的编译单元内，在当前编译单元内必须包含函数的定义，并且此函数只在当前编译单元内可见。
	//	5.6.3 标准C++库和命名空间
	//		标准C++库类与组件在逻辑上分6种：
	//			1. 输入 / 输出类；
	//			2. 容器类与抽象数据类型（ADT）；
	//			3. 存储管理类；
	//			4. 算法；
	//			5. 错误处理；
	//			6. 运行环境支持。
	//	5.6.4 编译预处理：编译器在对源程序进行编译之前，由预处理程序对程序文本进行预处理。
	//		所有预处理指令在程序中以“#”来引导，每条预处理指令单独占用一行，不用分号结束。
	//			1. #include 指令：嵌入头文件
	//			2. #define 和 #undef 指令：定义符号常量或者删除已经定义的符号常量
	//			3. 条件编译指令：在满足一定条件下代码才参与编译。
	//			4. defined(标识符)：判断标识符是否被定义 
	//				#if !define(MYHEAD_H) 
	//					#define MYHEAD_H 
	//					... 
	//				#endif

	cout << "===>Ch05<===" << endl;

	src0501(); cout << endl;
	src0502(); cout << endl;
	src0503(); cout << endl;
	src0504(); cout << endl;
	src0505(); cout << endl;
	src0506(); cout << endl;
	src0507(); cout << endl;
	src0508(); cout << endl;
	src0509(); cout << endl;
}
