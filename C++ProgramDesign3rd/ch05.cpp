#include <iostream>
#include "include/ch05.h"

using namespace std;

void ch05()
{
	//	P125，Ch05，C++程序的结构
	//5.1 标识符的作用域与可见性
	//	5.1.1 作用域：标识符在程序正文中有效的区域（函数原型作用域、块作用域即局部作用域、类作用域、文件作用域）
	//	1. 函数原型作用域：在函数原型声明时形式参数的作用范围
	//	2. 块作用域：在块中声明的标识符，其作用域从声明处开始，到块结束为止。具有块作用域的变量也称为局部变量
	//	3. 类作用域：在类的成员函数中如果没有声明同名的局部作用域标识符，那么在该函数内可以直接访问类的成员。变量x通过x::M或x.M访问，指针ptr通过ptr->M访问
	//	4. 文件作用域：在文件中声明的不同于其他三个的标识符，其作用域从声明处开始，到文件结束为止。
	//5.2 对象的生存期
	//	5.2.1 静态生存期：对象的生存期与程序的运行期相同
	//	5.2.2 动态生存期：对象自重于声明点，结束于该标识符作用域结束处。
	//5.3 类的静态成员变量：方便同一个类的不同对象之间共享数据。
	//	5.3.1 静态数据成员：
	//	实例属性：在类的每一个对象中都拥有一个实例，是每个对象之间的区别特征
	//	类属性：整个类所共有，不属于任何一个具体的对象。描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的。
	//	静态数据成员具有静态生存期，使用“类名::标识符”进行访问
	//	5.3.2 静态函数成员：可以直接访问该类的静态数据和函数成员。而访问非静态数据成员必须通过参数传递方式得到对象名，然后通过对象名来访问。
	//5.4 类的友元：
	//	友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。
	//	通过友元关系，一个普通函数或者类的成员函数可以访问封装于另一个类中的数据。
	//	同时，友元关系也是对数据隐藏和封装的破坏。
	//	5.4.1 友元函数：在类中使用关键字friend修饰的非成员函数
	//	友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是在补给线的函数体中可以通过对象名访问类的私有和保护成员。
	//	5.4.2 友元类：若A类是B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有成员和保护成员。
	//	友元关系不可传递；友元关系是单向的；友元关系不能继承。
	//5.5 共享数据的保护
	//	5.5.1 常引用：所引用的对象不能被更新
	//	5.5.2 常对象：必须进行初始化，而且不能被更新
	//	5.5.3 使用 const 修饰的对象的常成员
	//		1. 常成员函数：[类型说明符 函数名(参数表) const;]
	//			-	const 是函数类型的一个组成部分，因此在函数的定义部分也要带 const 关键字
	//			-	常成员函数不能更新对象的数据成员，也不能调用该类中没有用 const 修饰的成员函数（保证了在常成员函数中不会更改数据成员的值）
	//			-	通过常对象只能调用常成员函数，不能调用其他成员函数
	//			-	const 关键字可以用于对重载函数的区分
	//		2. 常数据成员

	cout << "===>Ch05<===" << endl;

	src0501(); cout << endl;
	src0502(); cout << endl;
	src0503(); cout << endl;
	src0504(); cout << endl;
	src0505(); cout << endl;
	src0506(); cout << endl;
	src0507(); cout << endl;
	src0508(); cout << endl;
	src0509(); cout << endl;
}
